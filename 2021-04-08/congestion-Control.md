## TCP 中常见的拥塞控制算法有哪些？

### 常见的拥塞控制算法包括：1.linux内核默认的Reno算法和Google的BBR算法

* 拥塞控制的概念  
    我们把网络链路上可以容纳的数据包数量，比喻成一根水管。我们希望这根水管可以尽可能地多  
    传输水，那我们就往水管里面注水就好了，但是我们又必须得考虑到水流量过大导致水管破裂的  
    情况，所以对比与网络环境来说，这个就是拥塞控制。在网络环境中，为了防止链路不会发生类似  
    于水管破裂的情况发生，TCP维护了一个拥塞窗口cwnd(congestion windows)，通过该窗口  
    来估计在一段时间内网络链路上面可以承受的最大数据包数量。拥塞窗口的大小取决于网络的拥塞  
    程度，并且动态地发生变化。（水管发生破裂，相对应网络中的现象就是丢包）


* 常见的拥塞控制算法
  * Linux内核默认的Reno算法
  * Google的BBR算法


* Reno算法
  * 该算法将拥塞控制的过程分为了四个阶段：慢启动、拥塞避免、快重传和快恢复
  ![avatar](./../PIC/CongestionControl.jpg)

  * <font color=red>慢启动</font>阶段的思路是不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大  
    逐渐增加拥塞窗口的大小，在没有出现丢包的时候，每收到一个ACK就将拥塞窗口大小加一（拥塞窗口  
    的单位是MSS，最大单个报文段长度），每次发送都将窗口增加一倍，呈指数增长；若出现丢包的情况  
    ，则将拥塞窗口减半，进入<font color=red>拥塞避免</font>阶段。
  * 当窗口达到慢启动阈值或出现丢包的时候，就进入拥塞避免状态，窗口每轮次大小加一，呈<font color=red>线性</font>增长；当收到  
    对一个报文的三个重复的ACK的时候，就认为这个报文的下一个报文丢失了，进入到<font color=red>快重传阶段</font>，要求  
    接收方在收到一个失去顺序的报文段之后，就立即发出重复确认(为的是使发送方及早知道有报文段没有  
    到达对方，可提高网络吞吐量约20%)而不要等到自己发送数据的时候捎带确认
  * 快重传阶段完成之后进入<font color=red>快恢复阶段</font>，将慢启动阈值修改为当前拥塞窗口  
    值的一半，同时拥塞窗口值等于慢启动阈值，然后进入拥塞避免阶段，重复上述过程。



