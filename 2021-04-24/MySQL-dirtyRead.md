## 简述脏读和幻读的发生场景，InnoDB是如何解决幻读的？

* 个人理解
  * 在InnoDB存储引擎中，事务隔离级别包括了读未提交，读提交，不可重复读，可串行化。四个隔离级别  
    的隔离强度是逐渐升高的。而脏读有可能会发生在读未提交的事务隔离级别下，幻读有可能发生在读未提交  
    和读提交隔离级别下。

  * 具体现象
    * 脏读：在时间戳t1下，事务A对数据data先进行读操作；在时间戳t2下，事务B对数据data进行了修改操作；
      在时间戳t3下，事务A再次对数据data进行读取。这时候发现所读取到的数据data内容发生了改变。（  
      时间戳t3>t2>t1）这就是脏读
    * 幻读：在时间戳t1下，事务A里面进行了一个带有条件的查询操作，最终查询到了结果集data；时间戳t2下，  
      事务B对结果集中的数据进行了新增或者删除数据的操作；在时间戳t3下，事务A再次进行t1时间戳下的条件  
      查询，这时候发现查询到的结果集和t1时刻所查找到的内容不同。这种现象就被称为幻读（时间戳t3>t2>t1）

    * 总体来说，首先是区别于针对单条数据查询还是范围查询来说的，其次幻读操作的条件查询，前后查询的条件  
      需要保持不变。


* 幻读的解决（个人看法）
  * InnoDB中，在RR隔离级别下，是通过MVCC和next-key lock（行锁+间隙锁的实现）来解决的；而可序列化隔离级别下，由于发生冲  
    突的事务之间，需要通过等待，所以可以完全避免幻读的发生。
  * next-lock key的相关概念
      * 加锁的基本单位是(next-lock key)，它满足前开后闭原则
      * 查询过程中访问的对象会增加锁
      * 索引上的等值查询——给唯一索引加锁的时候，next-key lock降级为行锁
      * 索引上的等值查询——向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁
      * 唯一索引上的范围查询会访问到不满足条件的第一个值为止

