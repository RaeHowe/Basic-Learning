## 数据库的事务隔离级别有哪些？各有哪些优缺点？

* MySQL数据库隔离级别包括了读未提交、读提交、可重复读、可串行化四种。数据隔离的强度逐渐提升，数据库访问  
  数据的并发性逐渐降低

* 个人理解
  * 读未提交
    * 该隔离级别是四种隔离级别最低的。在该隔离级别下，一个事务在执行的过程中，会读取到其他事务已经修改  
      但没有最终提交的数据信息，所以会引发脏读的问题。并且由于性能并不比其他的隔离级别强多少，所以该隔  
      离级别并不总被使用。
  * 读提交
    * 在该隔离级别下，解决了脏读问题。一个事务在执行的过程中，只能读取到其他事务已经修改并且被最终提交  
      了的数据信息。但是该隔离级别会产生不可重复读的问题。以为在事务的执行过程中，所涉及到的数据信息从  
      一开始在执行的过程中，并不能保证一直不变，会受到其他事务的影响。
  * 可重复读
    * 该隔离级别解决了不可重复读的问题，在MySQL中，引入了MVCC机制，使得在读取数据的时候只读取数据在某一  
      个版本下的数据信息快照，不会涉及到执行过程中数据发生变化的问题。但是会存在幻读的问题。
      （所谓幻读，比如事务A通过某个条件查询出来一个数据范围，另一个事务B改动了这个数据范围内部的数据内容。  
       此时事务A再次进行条件查询的时候，发现前后两次查询到的结果集数据不一致，该现象就是幻读问题）
      在MySQL中，解决幻读的办法一种是通过设置隔离级别为可串行化；另一种就是在可重复读的隔离级别下采用间隙  
      锁的方式来解决，MySQL把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做Next-key锁。
  * 可串行化
    * 该隔离级别是最严格的隔离级别，所以性能方面也会受到影响。该隔离级别保证每个事务在执行的时候，给所涉及  
      到的数据行加锁的方式，来防止数据被其他事务所修改。如果事务之间发生了锁冲突的话，就只能通过等待锁释放  
      来进行最后的数据操作。该隔离级别解决了幻读问题。


* 再复习一下next-lock key的相关概念
  * 加锁的基本单位是(next-lock key)，它满足前开后闭原则
  * 查询过程中访问的对象会增加锁
  * 索引上的等值查询——给唯一索引加锁的时候，next-key lock降级为行锁
  * 索引上的等值查询——向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁
  * 唯一索引上的范围查询会访问到不满足条件的第一个值为止


* 最后需要记住的是间隙锁是加在B+树的索引上面的，而不是直接在数据行之间的。