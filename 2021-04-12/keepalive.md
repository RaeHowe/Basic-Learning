## TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？

### HTTP中是keep-alive，TCP中是keepalive，HTTP中是带中划线的。大小写无所谓。

* TCP的keepalive
  * 简介：
      在TCP连接之后，双方如果长时间没有通讯的话，为了知道对方还活着，为了证明这个TCP连接是健康且  
      具有通讯能力的，TCP就设计了一种保活机制来解决该问题，这个机制被称作keepalive。保活机制默认  
      是关闭的，TCP连接的任何一方都可打开此功能。

  * 流程梳理：
    如果在一段时间（保活时间:tcp_keepalive_time）内，某个TCP连接不活跃的话，那么开启keepalive  
    功能的一端，就会向对端发起一个保活探测报文。
    * 如果对端正常存活，且连接有效的话，对端就会收到探测报文并进行响应。此时，发送端收到响应报文则证明  
      TCP连接正常，重置保活时间计数器即可。
    * 如果由于网络原因或者其他原因导致发送端无法收到探测报文的响应，那么在一定探测时间间隔(tcp_keepalive_intvl)  
      后，将继续发送保活探测报文。直到收到对端的响应；或者达到配置的探测循环次数上限(tcp_keepalive_probes)  
      都没有收到对端响应，这时对端会被认为不可达，TCP连接虽然存在，但是已经失效，需要将连接做中断处理。

* HTTP的keep-alive
  * 简介:
    HTTP协议在OSI七层模型中，处于应用层。它的特点是：客户端的每一次请求都要和服务端创建TCP连接，服务器响应后，断开  
    TCP连接。下次客户端再有请求，则重新建立连接。在HTTP1.0版本中，keep-alive机制默认是关闭的，需要通过设置请求头:  
    connection为keep-alive进行开启；不过在HTTP1.1版本中，这个机制默认是开启的了，但是可以通过HTTP请求头设置  
    connection:close进行关闭。
  * 流程梳理:
    * 开启该机制后，在一次HTTP请求中，服务器进行响应后，不再直接断开TCP连接，而是将TCP连接维持一段时间。在这段时间里，  
      如果同一个客户端再次向服务端发起HTTP请求的话，便可以复用此TCP连接，向服务端发起请求，并重置timeout时间计数器，在  
      接下来一段时间内，还可以继续复用。这样无疑省略了反复创建和销毁TCP连接的损耗。

* 总结
  * HTTP的keep-alive的优缺点：
    * 优点：keep-alive机制避免了频繁建立和销毁连接的开销。同时，减少服务端TIME_WAIT状态的TCP连接的数量
    * 缺点：如果keep-alive的timeout设置的时间较长，长时间的TCP链接维持，会一定程度的浪费系统资源。

* 个人理解两者的区别：
  TCP端的keepalive主要是为了保证进行TCP连接的双方，可以知道对方的存活状态，保持连接的健康；HTTP端的keep-alive主要是  
  为了实现避免每次请求过后，都断开连接的问题（短连接），避免了大量TIME_WAIT状态的连接存在于服务器中，影响端口使用和  
  其他TCP连接的创建问题。
